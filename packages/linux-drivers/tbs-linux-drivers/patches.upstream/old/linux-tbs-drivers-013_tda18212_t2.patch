diff -ru a/linux-tbs-drivers/linux/drivers/media/common/tuners/tda18212.h b/linux-tbs-drivers/linux/drivers/media/common/tuners/tda18212.h
--- a/linux-tbs-drivers/linux/drivers/media/common/tuners/tda18212.h	2011-04-20 06:45:54.000000000 +0300
+++ b/linux-tbs-drivers/linux/drivers/media/common/tuners/tda18212.h	2013-03-25 21:28:49.580814336 +0200
@@ -29,7 +29,13 @@
 	u16 if_dvbt_6;
 	u16 if_dvbt_7;
 	u16 if_dvbt_8;
+	u16 if_dvbt2_5;
+	u16 if_dvbt2_6;
+	u16 if_dvbt2_7;
+	u16 if_dvbt2_8;
 	u16 if_dvbc;
+	u8 loop_through:1;
+	u8 xtout:1;
 };
 
 #if defined(CONFIG_MEDIA_TUNER_TDA18212) || \
diff -ru a/linux-tbs-drivers/linux/drivers/media/common/tuners/tda18212.c b/linux-tbs-drivers/linux/drivers/media/common/tuners/tda18212.c
--- a/linux-tbs-drivers/linux/drivers/media/common/tuners/tda18212.c	2011-04-20 06:45:54.000000000 +0300
+++ b/linux-tbs-drivers/linux/drivers/media/common/tuners/tda18212.c	2013-03-25 21:36:44.148808870 +0200
@@ -126,6 +126,9 @@
 		{ 0xb3, 0x20, 0x03 }, /* DVB-T 6 MHz */
 		{ 0xb3, 0x31, 0x01 }, /* DVB-T 7 MHz */
 		{ 0xb3, 0x22, 0x01 }, /* DVB-T 8 MHz */
+		{ 0xbc, 0x20, 0x03 }, /* DVB-T2 6 MHz */
+		{ 0xbc, 0x72, 0x03 }, /* DVB-T2 7 MHz */
+		{ 0xbc, 0x22, 0x01 }, /* DVB-T2 8 MHz */
 		{ 0x92, 0x53, 0x03 }, /* DVB-C */
 	};
 
@@ -154,10 +157,32 @@
 			ret = -EINVAL;
 			goto error;
 		}
+		buf[0] = 0x30;
+		break;
+	case SYS_DVBT2:
+		switch (c->bandwidth_hz) {
+		case 6000000:
+			if_khz = priv->cfg->if_dvbt2_6;
+			i = 3;
+			break;
+		case 7000000:
+			if_khz = priv->cfg->if_dvbt2_7;
+			i = 4;
+			break;
+		case 8000000:
+			if_khz = priv->cfg->if_dvbt2_8;
+			i = 5;
+			break;
+		default:
+			ret = -EINVAL;
+			goto error;
+		}
+		buf[0] = 0x30;
 		break;
 	case SYS_DVBC_ANNEX_AC:
 		if_khz = priv->cfg->if_dvbc;
-		i = 3;
+		i = 6;
+		buf[0] = 0;
 		break;
 	default:
 		ret = -EINVAL;
@@ -168,17 +193,28 @@
 	if (ret)
 		goto error;
 
+	ret = tda18212_wr_reg(priv, 0x5f, 0x00);
+	if (ret)
+		goto error;
+
 	ret = tda18212_wr_reg(priv, 0x06, 0x00);
 	if (ret)
 		goto error;
 
+	if (priv->cfg->loop_through)
+		buf[0] |= 0x80;
+
+	ret = tda18212_wr_reg(priv, 0x0c, buf[0]);
+	if (ret)
+		goto error;
+
 	ret = tda18212_wr_reg(priv, 0x0f, bw_params[i][0]);
 	if (ret)
 		goto error;
 
 	buf[0] = 0x02;
 	buf[1] = bw_params[i][1];
-	buf[2] = 0x03; /* default value */
+	buf[2] = priv->cfg->xtout ? 0x43 : 0x40;
 	buf[3] = if_khz / 50;
 	buf[4] = ((c->frequency / 1000) >> 16) & 0xff;
 	buf[5] = ((c->frequency / 1000) >>  8) & 0xff;
@@ -207,6 +243,27 @@
 	return 0;
 }
 
+static int tda18212_sleep(struct dvb_frontend *fe)
+{
+	struct tda18212_priv *priv = fe->tuner_priv;
+	int ret;
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 1); /* open I2C-gate */
+
+	/* standby */
+	ret = tda18212_wr_reg(priv, 0x5f, 0xe0);
+	ret = tda18212_wr_reg(priv, 0x06, 0x08);
+
+	if (fe->ops.i2c_gate_ctrl)
+		fe->ops.i2c_gate_ctrl(fe, 0); /* close I2C-gate */
+
+	if (ret)
+		dbg("%s: failed ret:%d", __func__, ret);
+
+	return ret;
+}
+
 static const struct dvb_tuner_ops tda18212_tuner_ops = {
 	.info = {
 		.name           = "NXP TDA18212",
@@ -217,6 +274,7 @@
 	},
 
 	.release       = tda18212_release,
+	.sleep         = tda18212_sleep,
 
 	.set_params    = tda18212_set_params,
 };
