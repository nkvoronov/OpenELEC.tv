Author: Svante Signell <svante.signell@telia.com>
Description:
 libdvdread FTBFS on hurd-i386 due to PATH_MAX usage, which is not defined on
 GNU/Hurd. The attached patch fixes these problems by using dynamic buffer
 allocation (Closes: #640803).

--- a/src/dvd_reader.c
+++ b/src/dvd_reader.c
@@ -30,6 +30,7 @@
 #include <string.h>
 #include <strings.h>
 #include <ctype.h>
+#define _GNU_SOURCE
 #include <unistd.h>
 #include <limits.h>
 #include <dirent.h>
@@ -426,6 +427,12 @@
         if( chdir( path_copy ) == -1 ) {
           goto DVDOpen_error;
         }
+#ifdef __GLIBC__
+        new_path = get_current_dir_name();
+        if(new_path == NULL) {
+          goto DVDOpen_error;
+        }
+#else
         new_path = malloc(PATH_MAX+1);
         if(!new_path) {
           goto DVDOpen_error;
@@ -433,6 +440,7 @@
         if( getcwd( new_path, PATH_MAX ) == NULL ) {
           goto DVDOpen_error;
         }
+#endif
         retval = fchdir( cdir );
         close( cdir );
         cdir = -1;
@@ -627,17 +635,23 @@
  *     or -1 on file not found.
  *     or -2 on path not found.
  */
-static int findDirFile( const char *path, const char *file, char *filename )
+static int findDirFile( const char *path, const char *file, char **filename )
 {
   DIR *dir;
   struct dirent *ent;
+  *filename = NULL;
 
   dir = opendir( path );
   if( !dir ) return -2;
 
   while( ( ent = readdir( dir ) ) != NULL ) {
     if( !strcasecmp( ent->d_name, file ) ) {
-      sprintf( filename, "%s%s%s", path,
+      *filename = malloc( strlen( path ) + 1 + strlen( ent->d_name ) + 1 );
+      if( *filename == NULL ) {
+        closedir(dir);
+        return -1;
+      }
+      sprintf( *filename, "%s%s%s", path,
                ( ( path[ strlen( path ) - 1 ] == '/' ) ? "" : "/" ),
                ent->d_name );
       closedir(dir);
@@ -648,9 +662,9 @@
   return -1;
 }
 
-static int findDVDFile( dvd_reader_t *dvd, const char *file, char *filename )
+static int findDVDFile( dvd_reader_t *dvd, const char *file, char **filename )
 {
-  char video_path[ PATH_MAX + 1 ];
+  char *video_path = NULL;
   const char *nodirfile;
   int ret;
 
@@ -664,6 +678,8 @@
   ret = findDirFile( dvd->path_root, nodirfile, filename );
   if( ret < 0 ) {
     /* Try also with adding the path, just in case. */
+    video_path = malloc( strlen( dvd->path_root ) + 10 + 1 );
+    if( video_path == NULL ) return 0;
     sprintf( video_path, "%s/VIDEO_TS/", dvd->path_root );
     ret = findDirFile( video_path, nodirfile, filename );
     if( ret < 0 ) {
@@ -671,9 +687,11 @@
       sprintf( video_path, "%s/video_ts/", dvd->path_root );
       ret = findDirFile( video_path, nodirfile, filename );
       if( ret < 0 ) {
+        free( video_path );
         return 0;
       }
     }
+    free( video_path );
   }
 
   return 1;
@@ -684,20 +702,22 @@
  */
 static dvd_file_t *DVDOpenFilePath( dvd_reader_t *dvd, char *filename )
 {
-  char full_path[ PATH_MAX + 1 ];
+  char *full_path = NULL;
   dvd_file_t *dvd_file;
   struct stat fileinfo;
   dvd_input_t dev;
 
   /* Get the full path of the file. */
-  if( !findDVDFile( dvd, filename, full_path ) ) {
+  if( !findDVDFile( dvd, filename, &full_path ) ) {
     fprintf( stderr, "libdvdnav:DVDOpenFilePath:findDVDFile %s failed\n", filename );
+    free( full_path );
     return NULL;
   }
 
   dev = dvdinput_open( full_path );
   if( !dev ) {
     fprintf( stderr, "libdvdnav:DVDOpenFilePath:dvdinput_open %s failed\n", full_path );
+    free( full_path );
     return NULL;
   }
 
@@ -705,6 +725,7 @@
   if( !dvd_file ) {
     fprintf( stderr, "libdvdnav:DVDOpenFilePath:dvd_file malloc failed\n" );
     dvdinput_close(dev);
+    free( full_path );
     return NULL;
   }
   dvd_file->dvd = dvd;
@@ -716,6 +737,7 @@
 
   if( stat( full_path, &fileinfo ) < 0 ) {
     fprintf( stderr, "libdvdread: Can't stat() %s.\n", filename );
+    free( full_path );
     free( dvd_file );
     return NULL;
   }
@@ -723,6 +745,7 @@
   dvd_file->title_devs[ 0 ] = dev;
   dvd_file->filesize = dvd_file->title_sizes[ 0 ];
 
+  free( full_path );
   return dvd_file;
 }
 
@@ -778,7 +801,7 @@
 static dvd_file_t *DVDOpenVOBPath( dvd_reader_t *dvd, int title, int menu )
 {
   char filename[ MAX_UDF_FILE_NAME_LEN ];
-  char full_path[ PATH_MAX + 1 ];
+  char *full_path = NULL;
   struct stat fileinfo;
   dvd_file_t *dvd_file;
   int i;
@@ -801,13 +824,15 @@
     } else {
       sprintf( filename, "VTS_%02i_0.VOB", title );
     }
-    if( !findDVDFile( dvd, filename, full_path ) ) {
+    if( !findDVDFile( dvd, filename, &full_path ) ) {
+      free( full_path );
       free( dvd_file );
       return NULL;
     }
 
     dev = dvdinput_open( full_path );
     if( dev == NULL ) {
+      free( full_path );
       free( dvd_file );
       return NULL;
     }
@@ -815,6 +840,7 @@
     if( stat( full_path, &fileinfo ) < 0 ) {
       fprintf( stderr, "libdvdread: Can't stat() %s.\n", filename );
       dvdinput_close(dev);
+      free( full_path );
       free( dvd_file );
       return NULL;
     }
@@ -827,7 +853,7 @@
     for( i = 0; i < TITLES_MAX; ++i ) {
 
       sprintf( filename, "VTS_%02i_%i.VOB", title, i + 1 );
-      if( !findDVDFile( dvd, filename, full_path ) ) {
+      if( !findDVDFile( dvd, filename, &full_path ) ) {
         break;
       }
 
@@ -842,11 +868,12 @@
       dvd_file->filesize += dvd_file->title_sizes[ i ];
     }
     if( !dvd_file->title_devs[ 0 ] ) {
+      free( full_path );
       free( dvd_file );
       return NULL;
     }
   }
-
+  free( full_path );
   return dvd_file;
 }
 
@@ -968,7 +995,7 @@
                                int menu, dvd_stat_t *statbuf )
 {
   char filename[ MAX_UDF_FILE_NAME_LEN ];
-  char full_path[ PATH_MAX + 1 ];
+  char *full_path = NULL;
   struct stat fileinfo;
   off_t tot_size;
   off_t parts_size[ 9 ];
@@ -980,11 +1007,14 @@
   else
     sprintf( filename, "VTS_%02d_%d.VOB", title, menu ? 0 : 1 );
 
-  if( !findDVDFile( dvd, filename, full_path ) )
+  if( !findDVDFile( dvd, filename, &full_path ) ) {
+    free( full_path );
     return -1;
+  }
 
   if( stat( full_path, &fileinfo ) < 0 ) {
     fprintf( stderr, "libdvdread: Can't stat() %s.\n", filename );
+    free( full_path );
     return -1;
   }
 
@@ -996,7 +1026,7 @@
     int cur;
     for( cur = 2; cur < 10; cur++ ) {
       sprintf( filename, "VTS_%02d_%d.VOB", title, cur );
-      if( !findDVDFile( dvd, filename, full_path ) )
+      if( !findDVDFile( dvd, filename, &full_path ) )
         break;
 
       if( stat( full_path, &fileinfo ) < 0 ) {
@@ -1015,6 +1045,7 @@
   for( n = 0; n < nr_parts; n++ )
     statbuf->parts_size[ n ] = parts_size[ n ];
 
+  free( full_path );
   return 0;
 }
 
@@ -1023,7 +1054,7 @@
                  dvd_read_domain_t domain, dvd_stat_t *statbuf )
 {
   char filename[ MAX_UDF_FILE_NAME_LEN ];
-  char full_path[ PATH_MAX + 1 ];
+  char *full_path = NULL;
   struct stat fileinfo;
   uint32_t size;
 
@@ -1079,17 +1110,19 @@
       return 0;
     }
   } else {
-    if( findDVDFile( dvd, filename, full_path ) ) {
+    if( findDVDFile( dvd, filename, &full_path ) ) {
       if( stat( full_path, &fileinfo ) < 0 )
         fprintf( stderr, "libdvdread: Can't stat() %s.\n", filename );
       else {
         statbuf->size = fileinfo.st_size;
         statbuf->nr_parts = 1;
         statbuf->parts_size[ 0 ] = statbuf->size;
+        free( full_path );
         return 0;
       }
     }
   }
+  free( full_path );
   return -1;
 }
 
