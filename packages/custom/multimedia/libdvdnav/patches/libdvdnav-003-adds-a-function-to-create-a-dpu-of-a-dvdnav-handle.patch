From 5c7ddc5ca6cde54743b3ce019cb757022e47c71e Mon Sep 17 00:00:00 2001
From: Erik Hovland <erik@hovland.org>
Date: Mon, 21 May 2012 16:41:55 -0700
Subject: [PATCH] Adds a function to create a dpu of a dvdnav handle

This adds a function to create a duplicate of a dvdnav handle and it's
state. This allows you to recursively move through the handle. HandBrake
uses these functions to do recursive automated search of the menus for
something that looks like the main feature.
---
 src/dvdnav.c        |   61 +++++++++++++++++++++++++++++++++++++++++++++++++++
 src/dvdnav/dvdnav.h |    3 +++
 2 files changed, 64 insertions(+)

diff --git a/src/dvdnav.c b/src/dvdnav.c
index 5859d6e..5349ecd 100644
--- a/src/dvdnav.c
+++ b/src/dvdnav.c
@@ -71,6 +71,67 @@ static dvdnav_status_t dvdnav_clear(dvdnav_t * this) {
   return DVDNAV_STATUS_OK;
 }
 
+dvdnav_status_t dvdnav_dup(dvdnav_t **dest, dvdnav_t *src) {
+  dvdnav_t *this;
+
+  (*dest) = NULL;
+  this = (dvdnav_t*)malloc(sizeof(dvdnav_t));
+  if(!this)
+    return DVDNAV_STATUS_ERR;
+
+  memcpy(this, src, sizeof(dvdnav_t));
+  this->file = NULL;
+
+  pthread_mutex_init(&this->vm_lock, NULL);
+
+  this->vm = vm_new_copy(src->vm);
+  if(!this->vm) {
+    printerr("Error initialising the DVD VM.");
+    pthread_mutex_destroy(&this->vm_lock);
+    free(this);
+    return DVDNAV_STATUS_ERR;
+  }
+
+  /* Start the read-ahead cache. */
+  this->cache = dvdnav_read_cache_new(this);
+
+  (*dest) = this;
+  return DVDNAV_STATUS_OK;
+}
+
+dvdnav_status_t dvdnav_free_dup(dvdnav_t *this) {
+
+#ifdef LOG_DEBUG
+  fprintf(MSG_OUT, "libdvdnav: free_dup:called\n");
+#endif
+
+  if (this->file) {
+    pthread_mutex_lock(&this->vm_lock);
+    DVDCloseFile(this->file);
+#ifdef LOG_DEBUG
+    fprintf(MSG_OUT, "libdvdnav: close:file closing\n");
+#endif
+    this->file = NULL;
+    pthread_mutex_unlock(&this->vm_lock);
+  }
+
+  /* Free the VM */
+  if(this->vm)
+    vm_free_copy(this->vm);
+
+  pthread_mutex_destroy(&this->vm_lock);
+
+  /* We leave the final freeing of the entire structure to the cache,
+   * because we don't know, if there are still buffers out in the wild,
+   * that must return first. */
+  if(this->cache)
+    dvdnav_read_cache_free(this->cache);
+  else
+    free(this);
+
+  return DVDNAV_STATUS_OK;
+}
+
 dvdnav_status_t dvdnav_open(dvdnav_t** dest, const char *path) {
   dvdnav_t *this;
   struct timeval time;
diff --git a/src/dvdnav/dvdnav.h b/src/dvdnav/dvdnav.h
index 3e1b91a..ca78099 100644
--- a/src/dvdnav/dvdnav.h
+++ b/src/dvdnav/dvdnav.h
@@ -89,6 +89,9 @@ typedef int32_t dvdnav_status_t;
  */
 dvdnav_status_t dvdnav_open(dvdnav_t **dest, const char *path);
 
+dvdnav_status_t dvdnav_dup(dvdnav_t **dest, dvdnav_t *src);
+dvdnav_status_t dvdnav_free_dup(dvdnav_t *this);
+
 /*
  * Closes a dvdnav_t previously opened with dvdnav_open(), freeing any
  * memory associated with it.
-- 
1.7.10.4

